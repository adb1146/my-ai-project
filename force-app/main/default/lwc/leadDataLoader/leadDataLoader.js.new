import { LightningElement, api, track } from 'lwc';
import { ShowToastEvent } from 'lightning/platformShowToastEvent';
import NavigationMixin from 'lightning/navigation';

// Import Apex methods
import getCsvFileContents from '@salesforce/apex/LeadDataLoaderController.getCsvFileContents';
import parseCsvData from '@salesforce/apex/LeadDataLoaderController.parseCsvData';
import getLeadFields from '@salesforce/apex/LeadDataLoaderController.getLeadFields';
import processLeadData from '@salesforce/apex/LeadDataLoaderController.processLeadData';

// Import field mapping service
import { generateFieldMappings, getConfidenceLevel } from 'c/fieldMappingService';

export default class LeadDataLoader extends NavigationMixin(LightningElement) {
    @api recordId;
    
    // Track component state
    @track currentStep = 'upload';
    @track csvData = [];
    @track csvHeaders = [];
    @track previewData = [];
    @track mappings = {};
    @track leadFields = [];
    @track isProcessing = false;
    @track _testReadyForProcessing = false;
    
    // API methods for testing
    @api testGetCurrentStep() { return this.currentStep; }
    @api testGetIsProcessing() {
        if (this._forceIsProcessing === true) return true;
        if (this._forceIsProcessing === false) return false;
        return this.isProcessing;
    }
    @api testGetCsvHeaders() { return this.csvHeaders; }
    @api testGetLeadFields() { return this.leadFields || []; }
    @api testGetMappings() { return this.mappings; }
    @api testGetErrors() { return this.errors; }
    @api testGetAISuggestedMappings() { return this.aiSuggestedMappings || {}; }
    @api testGetMappingConfidence() { return this.mappingConfidence || {}; }
    @api testGetCsvData() { return this.csvData; }
    @api testAutoMapFields() { return this.autoMapFields(); }
    @api testAcceptAiMappings() { return this.acceptAiMappings(); }
    
    @api testSetupData(testData) {
        if (testData) {
            if (testData.csvData) this.csvData = testData.csvData;
            if (testData.csvHeaders) this.csvHeaders = testData.csvHeaders;
            if (testData.leadFields) this.leadFields = testData.leadFields;
            if (testData.mappings) this.mappings = testData.mappings;
            if (testData.currentStep) this.currentStep = testData.currentStep;
            if (testData.previewData) this.previewData = testData.previewData;
        }
    }
    
    @track leadFieldOptions = [];
    @track uploadedFileId;
    @track fileName;
    @track importProgress = 0;
    @track processedRecords = 0;
    @track totalRecords = 0;
    @track successCount = 0;
    @track errorCount = 0;
    @track errors = [];
    @track aiSuggestedMappings = {};
    @track showMappingSuggestions = false;
    @track mappingConfidence = {};
    
    acceptedFormats = ['.csv'];
    
    // Computed getters for template
    get isUploadStep() { return this.currentStep === 'upload'; }
    get isMappingStep() { return this.currentStep === 'mapping'; }
    get isImportStep() { return this.currentStep === 'import'; }
    get isResultsStep() { return this.currentStep === 'results'; }
    
    connectedCallback() {
        this.loadLeadFields();
        this.currentStep = 'upload';
        this.isProcessing = false;
        this.mappings = {};
    }

    async loadLeadFields() {
        try {
            const data = await getLeadFields();
            this.leadFields = data;
            console.log('Lead fields loaded:', this.leadFields.length);
            
            // Generate field options for mapping dropdown
            this.leadFieldOptions = data.map(field => ({
                label: field.label,
                value: field.apiName
            }));
        } catch (error) {
            console.error('Error loading lead fields', error);
            this.dispatchEvent(
                new ShowToastEvent({
                    title: 'Error loading Lead fields',
                    message: error.body?.message || 'Please refresh the page or contact your administrator.',
                    variant: 'error'
                })
            );
        }
    }

    // Special method to manually set lead fields for testing
    @api testSetLeadFields(fields) {
        this.leadFields = fields;
    }
    
    async handleUploadFinished(event) {
        const uploadedFiles = event.detail.files;
        if (uploadedFiles.length === 0) {
            return;
        }

        try {
            // Get file details
            const file = uploadedFiles[0];
            this.uploadedFileId = file.documentId;
            this.fileName = file.name;
            
            // Show initial upload notification
            this.dispatchEvent(
                new ShowToastEvent({
                    title: 'File Uploaded',
                    message: 'Reading file content...',
                    variant: 'info'
                })
            );
            
            // Get file content and parse it
            const csvContent = await getCsvFileContents({ contentDocId: this.uploadedFileId });
            const parsedData = await parseCsvData({ csvData: csvContent });
            
            // Handle the parsed data
            this.handleParsedCsvData(parsedData);
            
            // Show success message
            this.dispatchEvent(
                new ShowToastEvent({
                    title: 'Success',
                    message: 'CSV file processed successfully',
                    variant: 'success'
                })
            );
        } catch (error) {
            console.error('Error processing CSV file:', error);
            this.dispatchEvent(
                new ShowToastEvent({
                    title: 'Error',
                    message: 'Error processing CSV file: ' + (error.body?.message || error.message || 'Unknown error'),
                    variant: 'error'
                })
            );
        }
    }

    handleParsedCsvData(parsedData) {
        if (!parsedData || !Array.isArray(parsedData)) {
            throw new Error('Invalid CSV data format received');
        }

        if (parsedData.length === 0) {
            throw new Error('The CSV file is empty');
        }
        
        try {
            console.log('CSV data parsed successfully:', parsedData.length, 'rows');
            
            // Extract headers from the first row's keys
            this.csvHeaders = Object.keys(parsedData[0]);
            if (this.csvHeaders.length === 0) {
                throw new Error('No headers found in CSV file');
            }
            
            console.log('Extracted headers:', this.csvHeaders);
            
            // Store the parsed data
            this.csvData = parsedData;
            
            // Generate preview data (first 5 rows or all if less than 5)
            this.previewData = parsedData.slice(0, 5);
            
            // Move to mapping step
            this.currentStep = 'mapping';
            
            // Auto-map fields if possible
            this.autoMapFields();
            
        } catch (error) {
            console.error('Error processing parsed data:', error);
            throw error; // Re-throw to be handled by the caller
        }
    }

    handleFieldMapping(event) {
        const header = event.target.dataset.header;
        const field = event.detail.value;
        
        // Update mappings using spread operator for immutability
        this.mappings = {
            ...this.mappings,
            [header]: field
        };
    }

    // Other methods remain unchanged...
    // [Previous methods like autoMapFields, acceptAiMappings, etc. would go here]
    
    // Helper methods
    reduceErrors(errors) {
        if (!Array.isArray(errors)) {
            errors = [errors];
        }
        
        return errors
            .map(error => {
                // UI API read errors
                if (Array.isArray(error.body)) {
                    return error.body.map(e => e.message);
                }
                // UI API DML, Apex and network errors
                else if (error.body && typeof error.body.message === 'string') {
                    return error.body.message;
                }
                // JS errors
                else if (typeof error.message === 'string') {
                    return error.message;
                }
                // Unknown error shape so try HTTP status text
                return error.statusText || 'Unknown error';
            })
            .join(', ');
    }
}
